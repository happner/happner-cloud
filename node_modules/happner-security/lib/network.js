module.exports = NetworkManager;

function NetworkManager() {}

var _const = require('./_constants');

NetworkManager.prototype.__cachedPermissions = null;
NetworkManager.prototype.getPermissions = function($happn, params, callback) {

	try{

		if (!params) params = {};

		if (!this.__cachedPermissions || params.nocache){

			var _this = this;
			var permissions = {events:{}, data:{}, methods:{}};

			/*
			var permissions = {

				//we have versioning every permission update
				_version:0,

				// Data: A list representing raw pathways to functionality on
				// components data and accessable by web.
				
				data: {
					'/meshname/componentname/data': {},
					'/happner-cloud/componentname/data': {}
				},

				events: {
					'/meshname/componentname/eventname': {},
					'/happner-cloud/componentname/eventname': {}
				},

				// Methods: A list representing raw pathways to functionality on
				// the exchange and accessable by web.
				// - For assignment of users directly to functions.
				// - NB: TODO: Only paths to local components.

				methods: {
					'/happner-cloud/*':{
						description:'anything on this mesh'
					}
				},

				// Groups: Present list of pre configured mesh groups.
				// - Internally the mesh's components present a list of groups and
				//   their allowed paths, the mesh config should then map it's groups 
				//   to the component groups. 

				groups: {
					admin: {
						name: 'admin',
						description: 'Crane 9-1-9 Admin',
						network: '/harbour/quay9/berth1/crane9',
						groupType: 'builtin'
					},
					operator: {
						name: 'operator',
						description: 'Crane 9-1-9 Operator',
						network: '/harbour/quay9/berth1/crane9',
						groupType: 'configured',
					},
					technician: {
						name: 'technician',
						description: 'Crane 9-1-9 Technician',
						network: '/harbour/quay9/berth1/crane9',
						groupType: 'configured',
					}
				}
			};*/

			var meshName = $happn._mesh.config.name;

			for (var componentName in $happn.exchange[meshName]){
				for (var methodName in $happn.exchange[meshName][componentName]) {
					permissions.methods['/' + meshName + '/' + componentName + '/' + methodName] = {
						type: 'exchange'
					};
				}
			}

			for (var componentName in $happn.event[meshName]){
				for (var eventName in $happn.event[meshName][componentName]) {
					permissions.events['/' + meshName + '/' + componentName + '/' + eventName] = {
						keys:[]
					};
				}
			}

			for (var componentName in $happn._mesh.config.components) {
				try {
					for (var webMethod in $happn._mesh.config.components[componentName].web.routes) {
						permissions.methods['/' + meshName + '/' + componentName + '/' + webMethod] = {
							type: 'web'
						};
					}
				} catch (e) {}
			}


			this.__cachedPermissions = permissions;

			// console.log(this.__cachedPermissions);
		}
		
		if (params.group)
			callback(null, this.__cachedPermissions[params.group]);
		else
			callback(null, this.__cachedPermissions);

	}catch(e){
		callback(e);
	}

}

NetworkManager.prototype.__listening = false;
NetworkManager.prototype.listenSecurityDirectory = function($happn, params, callback) {

	try{

		if (!this.__listening){

			var _this = this;

			$happn.data.on(_const.CHANNEL.ALL, {event_type:'all'}, 
			function(data){
				
				//stuff gets decided on, sometimes we must relay messages

				if (data.channel == _const.CHANNEL.PERMISSION){
					//should be enough - when someone next gets it all is fine
					return cachedPermissions = false;
				}

				if (data.channel == _const.CHANNEL.USER){
					
				}

				if (data.channel == _const.CHANNEL.GROUP){
					
				}

				_this.networkSecurityEvent($happn, data);
			}, 
			function(e){
				if (e) return callback(e);	
				this.__listening == true;
				callback();
			})
		}else
			callback();

	}catch(e){
		callback(e);
	}

}

//updates all security-wise components something has changed on the local level - also listened on
//by the user interface
NetworkManager.prototype.securityEvent = function($happn, data, callback){
	try{
		console.log('about to emit', data);
		data.timestamp = Date.now();
		$happn.emit(_const.CHANNEL.LOCAL_NETWORK, data);
		if (callback)
			callback();
	}catch(e){
		if (callback)
			callback(e);
		else
			throw e;
	}
}

NetworkManager.prototype.start = function($happn, params, callback){

	try{

		var _this = this;

		_this.getPermissions($happn, {nocache:true}, function(e, permissions){

			if (e) return callback(e);

			_this.listenSecurityDirectory($happn, {}, function(e, response){

				if (e) return callback(e);

				callback();
			});

			callback();
		});

	}catch(e){
		callback(e);
	}


	
}
