module.exports = NetworkManager;

function NetworkManager() {}

var _const = require('./_constants');

NetworkManager.prototype.__cachedPermissions = null;
NetworkManager.prototype.getPermissions = function($happn, params, callback) {

	try{

		if (!params)
		params = {};

		if (!this.__cachedPermissions || params.nocache){

			var _this = this;

			var permissions = {

				events: {
					'/meshname/componentname/eventname': {},
					'/happner-cloud/componentname/eventname': {}
				},

				// Methods: A list representing raw pathways to functionality on
				// the exchange and accessable by web.
				// - For assignment of users directly to functions.
				// - NB: TODO: Only paths to local components.

				methods: {
					'/happner-cloud/*':{
						description:'anything on this mesh'
					}
				},

				// Groups: Present list of pre configured mesh groups.
				// - Internally the mesh's components present a list of groups and
				//   their allowed paths, the mesh config should then map it's groups 
				//   to the component groups. 

				groups: {
					admin: {
						name: 'admin',
						description: 'Crane 9-1-9 Admin',
						network: '/harbour/quay9/berth1/crane9',
						groupType: 'builtin'
					},
					operator: {
						name: 'operator',
						description: 'Crane 9-1-9 Operator',
						network: '/harbour/quay9/berth1/crane9',
						groupType: 'configured',
					},
					technician: {
						name: 'technician',
						description: 'Crane 9-1-9 Technician',
						network: '/harbour/quay9/berth1/crane9',
						groupType: 'configured',
					}
				}
			};

			var meshName = $happn._mesh.config.name;

			for (var componentName in $happn.exchange[meshName]){
				for (var methodName in $happn.exchange[meshName][componentName]) {
					permissions.methods['/' + meshName + '/' + componentName + '/' + methodName] = {
						type: 'exchange'
					};
				}
			}

			for (var componentName in $happn._mesh.config.components) {
				try {
					for (var webMethod in $happn._mesh.config.components[componentName].web.routes) {
						permissions.methods['/' + meshName + '/' + componentName + '/' + webMethod] = {
							type: 'web'
						};
					}
				} catch (e) {}
			}


			this.__cachedPermissions = permissions;

			// console.log(this.__cachedPermissions);
		}
		
		callback(null, this.__cachedPermissions)

	}catch(e){
		callback(e);
	}

}

NetworkManager.prototype.__listening = false;
NetworkManager.prototype.listenSecurityDirectory = function($happn, params, callback) {

	try{

		if (!this.__listening){

			var _this = this;

			$happn.data.on(_const.CHANNEL.ALL, {event_type:'all'}, 
			function(data){
				
				if (data.channel == _const.CHANNEL.PERMISSION){
					//should be enough - when someone next gets it all is fine
					return cachedPermissions = false;
				}

				/*
				if (data.channel == _const.CHANNEL.USER){
					
				}

				if (data.channel == _const.CHANNEL.GROUP){
					
				}
				*/

				_this.networkEvent($happn, data);
			}, 
			function(e){
				if (e) return callback(e);	
				this.__listening == true;
				callback();
			})
		}else
			callback();

	}catch(e){
		callback(e);
	}

}

NetworkManager.prototype.networkEvent = function($happn, data, callback){

	$happn.emit(_const.CHANNEL.NETWORK, data);

	if (callback)
		callback();
}

NetworkManager.prototype.start = function($happn, params, callback){

	try{

		var _this = this;

		_this.getPermissions($happn, {nocache:true}, function(e, permissions){

			if (e) return callback(e);

			_this.listenSecurityDirectory($happn, {}, function(e, response){

				if (e) return callback(e);

				callback();
			});

			callback();
		});

	}catch(e){
		callback(e);
	}


	
}
