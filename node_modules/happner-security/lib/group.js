module.exports = GroupManager;

function GroupManager() {}

GroupManager.prototype.PATH_GroupManager = '/HAPPNER-DTA/NETWORK/GROUP'; //permissions changed
GroupManager.prototype.PATH_SD_UPDATE = '/HAPPNER-EVT/NETWORK/SD_UPDATE'; //security directory update

var adminMethods = [
	{path: '/happner-cloud/*', permit: 'RWX'}
];

var adminEvents = [
	{path: '/happner-cloud/*', permit: 'RWX'}
];

var exampleMethods = [
	{path: '/happner-cloud/serverroom/cabinet2/aircon/runDiagnostics', permit: 'R-X'}
];

var exampleEvents = [
	{path: '/happner-cloud/serverroom/cabinet2/sensors/overheating', permit: 'R--'}
];


var _groups = {  // could put this into the start method to use $happn vars
	admin: {
		name: 'admin',
		description: 'Builtin admin group',
		groupType: 'builtin',
		network: '/OEM/company/plant/happner-cloud',
		methods: adminMethods,
		events: adminEvents,
		groups: [], // groups contain groups,
		_store:{
			id:'829827892789278927982'
		}
	},
	example: {
		name: 'example',
		description: 'Exmple group.',
		groupType: 'configured', // created by ui
		network: '/OEM/company/plant/happner-cloud',
		methods: exampleMethods,
		events: exampleEvents,
		groups: [],
		_store:{
			id:'829827892789278927983'
		}
	}
}

var lastId = 1;

GroupManager.prototype.create = function($happn, params, callback) {
	
	var name = params.data.name;
	var description = params.data.description;

	//console.log('in backend g create', params);

	if (_groups[name]) return callback(new Error('Group already exists.'));

	var group = {
		name: name,
		description: description || '',
		groupType: 'configured',
		network: '/OEM/company/plant/' + $happn._mesh.config.name,
		methods: [],
		events: [],
		_store:{}
	}

	lastId++;

	//this is a mockery of the actual save
	group._store.id = lastId;

	try{
		_groups[name] = group;

		//console.log('after backend g create', _groups);

		callback(null, group);
	}catch(e){
		callback(e);
	}

}

GroupManager.prototype.delete = function($happn, params, callback) {

	var name = params.name; // (KEY) The group being deleted

	try{
		if (params.name == 'admin') return callback(new Error('Not permitted'));
		if (_groups[name]) {
			delete _groups[name];
			callback(null, 1);
		} else {
			callback(null, 0);
		}
	}catch(e){
		callback(e);
	}

}

GroupManager.prototype.update = function($happn, params, callback) {

	//console.log('in backend g update', params);

	var name = params.data.name; // (KEY) The group being modified
	var description = params.data.description; // can change description. not name

	try{

		if (!_groups[name]) throw new Error('group does not exist');

		var group = _groups[name];
		group.description = description;

		callback(null, group);

	}catch(e){
		callback(e);
	}

}

// only adds methods
GroupManager.prototype.addPermissions = function($happn, params, callback){

	var name = params.name;				// (KEY) The group being modified

	var groups = params.groups;		// List (array) of groups whose permissions should be
																// inherited by this group.
																// 
																// groups = [{name: '..', network: '..'}, ...]

	var methods = params.methods;	// List (array) of paths to include as accessable to this group
																// 
																// methods = [{path: '/path/2', permit: 'R-X'}, ...]

	var events = params.events;   // List (array) of events to include as accessable to this group
																//
																// events = [{path: '/path/', 'permit: 'R--'}, ...]

	try{

		var group = _groups[name];

		methods.forEach(function(pending) {
			group.methods.push(pending);
		});

		// callback(null, group);
		callback(null);

	}catch(e){
		callback(e);
	}

}

// only removes methods
GroupManager.prototype.removePermissions = function($happn, params, callback){

	var name = params.name;
	var groups = params.groups; // same as for .addPermissions()
	var methods = params.methods; // list to remove [{path: '/path/'}, ...]
	var events = params.events;

	try{

		var group = _groups[name];
		count = group.methods.length;
		methods.forEach(function(remove) {
			group.methods = group.methods.filter(function(method) {
				return method.path !== remove.path;
			});
		});
		callback(null, count - group.methods.length); // delete count

	}catch(e){
		callback(e);
	}

}

GroupManager.prototype.clone = function($happn, params, callback){

	var sourceName = params.sourceName;
	var name = params.name;
	

	try{

		if (!_groups[sourceName]) return new callback(new Error('No source group'));
		if (_groups[name]) return new callback(new Error('Cannot overwrite existing group'));

		var group = JSON.parse(JSON.stringify(_groups[sourceName]));
		group.name = name;
		group.description = 'COPIED ' + group.description;
		group.groupType = 'configured';
		_groups[name] = group;
		callback(null, group);
	
	}catch(e){
		callback(e);
	}

}

GroupManager.prototype.list = function($happn, params, callback){

	var name = params.name; // optional (to list only one)
	
	try{

		if (name) callback(null, [_groups[name]]);
		return callback(null, Object.keys(_groups).map(function(name) {
			return _groups[name];
		}));

	}catch(e){
		callback(e);
	}

}

GroupManager.prototype.__refreshCache = function($happn, params, callback){

	try{
		if (callback) callback();
	}catch(e){
		$happn.log.error('error refreshing GroupManager cache', e);
		if (callback) callback(e);
	}

}

GroupManager.prototype.start = function($happn, params, callback){

	try{

		var _this = this;

		_this.__refreshCache($happn, {}, function(e){

			if (e) return callback(e);

			$happn.event.happnerSecurityNetwork.on('NETWORK-EVT', function(){
				_this.__refreshCache($happn, {});
			}, callback);

		});

	}catch(e){
		callback(e);
	}

	
}
